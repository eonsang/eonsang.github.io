---
title: 24-01 오브젝트
date: '2024-01-05'
tags: ['OOP', '오브젝트', '객체지향']
draft: false
description:
imgSrc: /static/books/object.jpg
---

## 1장 객체, 설계

- 소프트웨어 모듈의 목적은 제대로 실행되어야 하고, 변경이 용이해야 하며, 이해하기 쉬워야 한다.
- 하나의 클래스나 메서드에서 너무 많은 세부사항을 다루면 코드를 작성하는 사람뿐만 아니라 코드를 읽고 이해해야 하는 사람 모두에게 큰 부담을 준다.
- A클래스가 B클래스의 내부에 대해 많이 알면 알수록 변경하기 어려워진다. 이는 `의존성`과 관련된 문제다. = `결합도`가 높다.
- 설계의 목표는 객체 사이의 `결합도를 낮춰` 변경이 용이한 설계를 만드는 것이어야 한다.
- 객체 내부의 세부적인 사항을 감추는 것을 `캡슐화`라고 부른다. 목적은 변경하기 쉬운 객체를 만드는 것이다.
- 객체를 인터페이스와 구현으로 나누고 인터페이스만을 공개하는 것은 객체 사이의 결합도를 낮추고 변경하기 쉬운 코드를 작성하기 위해 따라야 하는 가장 기본적인 설계 원칙이다.
- 자신의 데이터를 스스로 처리하는 자율적인 객체를 만들면 결합도를 낮출 수 있을뿐더러 응집도를 높일 수 있다.
- 외부의 간섭을 최대한 배제하고 메시지를 통해서만 협력하는 자율적인 객체들의 공동체를 만드는 것이 훌륭한 객체지향 설계를 얻을 수 있는 지름길인 것이다.
- 변경하기 쉬운 설계는 한 번에 하나의 클래스만 변경할 수 있는 설계이다.
- 훌륭한 객체지향 설계의 핵심은 캡슐화를 이용해 의존성을 적절히 관리함으로써 객체 사이의 결합도를 낮추는 것이다.
- 객체지향 설계의 핵심은 적절한 객체에 적절한 책임을 할당하는 것이다.
- 설계를 어렵게 만드는 것은 `의존성`이다.
- 불필요한 세부사항을 캡슐화하는 자율적인 객체들이 낮은 결합도와 높은 응집도를 가지고 협력하도록 최소한의 의존성만을 남기는 것이 훌륭한 객체지향 설계이다.
- 설계는 트레이드오프의 산물이다.
- 객체지향의 세계에서는 현실에서 수동적인 존재(소극장, 오피스 등)라도 `의인화`를 통해 능동적인 존재로 바꾼다.
- 설계란 코드를 배치하는 것이다.
- 오늘 완성해야 하는 기능을 구현하는 코드를 짜야 하는 도잇에 내일 쉽게 변경할 수 있는 코드를 짜야한다.
- 변경가능한 코드란 이해하기 쉬운 코드다.

---

## 2장 객체지향 프로그래밍

- 진정한 객체지향 패러다임으로의 전환은 클래스가 아닌 객체에 초점을 맞출 때에만 얻을 수 있다.
  - 첫째, 어떤 클래스가 필요한지가 아니라, 어떤 `객체`가 필요한지를 고민하라
  - 둘째, 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야 한다.
- 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야를 도메인이라고 부른다.
- 클래스 사이의 관계도 최대한 도메인 개념 사이에 맺어진 관계와 유사하게 만들어서 프로그램의 구조를 이해하고 예상하기 쉽게 만들어야 한다.
- 클래스를 설계하기 위한 핵심은 어떤 부분을 외부에 공개하고, 어떤 부분을 감출지를 결정하는 것이다.
- 인터페이스와 구현의 분리 원칙은 훌륭한 객체지향 프로그램을 만들기 위해 따라야 하는 핵심 원칙이다.
- 클래스를 개발할때, 인터페이스와 구현을 깔끔하게 분리하기 위해 노력해야 한다.
- 설계가 필요한 이유는 변경을 관리하기 위해서라는 것을 기억하라.
- 객체지향의 장점은 객체를 이용해 도메인의 의미를 풍부하게 표현할 수 있다는 것이다.
- 코드의 의존성과 실행 시점의 의존성이 다를 수 있다.
- 항상 유연성과 가독성 사이에서 고민해야 한다.
- 상속이 가치 있는 이유는 부모 클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려받을 수 있기 때문이다.
- 인터페이스는 객체가 이해할 수 잇는 메시지의 목록을 정의한다는 것을 기억하라.
- 동일한 메시지를 전송하지만 실제로 어떤 메서드가 실행될 것인지는 메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라진다. 이를 `다형성`이라고 부른다
- `다형성`은 객체지향 프로그램의 컴파일 시간 의존성과 실행 시간 의존성이 다를 수 있다는 사실을 기반으로 한다.
- 다형성을 구현하는 방법은 매우 다양하지만 메시지에 응답하기 위해 실행될 메서드를 컴파일 시점이 아닌 실행 시점에 결정한다는 공통점이 있다.

---

## 3장 역할, 책임, 협력

- 객체지향 패러다임의 관점에서 핵심은 역할(role), 책임(responsibility), 협력(collaboration)이다.
- 객체지향의 본질은 협력하는 객체들의 공동체를 창조하는 것이다.
- 중요한 것은 기능을 구현하기 위해 메시지를 주고받으면서 상호작용을 한다는 점이다.
  - 상호작용을 `협력`, 협력에 참여하기 위해 수행하는 로직을 `책임`, 협력안에서 수행하는 책임들이 모여 객체가 수행하는 `역할`
- `메시지 전송`은 객체 사이의 협력을 위해 사용할 수 있는 유일한 커뮤니케이션 수단이다.
- 자신이 할 수 없는 일을 다른 객체에게 위임하면 협력에 참여하는 객체들의 전체적인 자율성을 향상시킬 수 있다.
- 객체지향 설계의 핵심은 적절한 객체에게 적절한 책임을 할당하는 것이다.
- 애플리케이션 안에 어떤 객체가 필요하다면 그 이유는 단 하나여야 한다. 그객체가 어떤 협력에 참여하고 있기 때문이다.
- 객체의 행동을 결정하는 것이 협력이라면 객체의 상태를 결정하는 것은 행동이다.
- 협력은 객체를 설계하는 데 필요한 일종의 `문맥`을 제공한다.
- 책임이란 객체에 의해 정의되는 응집도 있는 행위의 집합으로, 객체가 유지해야 하는 정보와 수행할 수 있는 행동에 대한 개략적으로 서술한 문장이다.
- 책임의 관점에서 `아는 것`과 `하는 것`이 밀접하게 연관돼 있다는 점이다.
- 객체지향 개발에서 가장 중요한 능력은 책임을 능숙하게 소프트웨어 객체에 할당하는 것
- 협력을 설계하는 출발점은 시스템이 사용자에게 제공하는 기능을 시스템이 담당할 하나의 책임으로 바라보는 것이다.
- 객체지향 설계는 시스템의 책임을 완료하는 데 필요한 더 작은 책임을 찾아내고 이를 객체들에게 할당하는 반복적인 광정을 통해 모양을 갖춰간다.
- 객체지향 설계는 협력에 필요한 메시지를 찾고, 메시지를 적절한 객체를 선택하는 반복적인 과정을 통해 이뤄진다.
- 구현이 아닌 책임에 집중하는 것이 중요한 이유는 유연하고 견고한 객체지향 시스템을 위해 가장 중요한 재료가 바로 책임이기 때문이다.
- 객체가 충분히 추상적이면서 미니멀리즘을 따르는 인터페이스를 가지게 하고 싶다면 메시지가 객체를 선택하게 하라.
- 객체지향 패러다임에 갓 입문한 사람들이 가장 쉽게 빠지는 실수는 객체의 행동이 아니라 상태에 초점을 맞추는 것이다.
- 개별 객체의 상태와 행동이 아닌 시스템의 기능을 구현하기 위한 협력에 초점을 맞춰야만 응집도가 높고 결합도가 낮은 객체들을 창조할 수 있다.
- 협력이 객체의 행동을 결정하고, 행동이 상태를 결정한다. 그 행동이 바로 객체의 책임이다.
- 역할이 중요한 이유는 역할을 통해 유연하고 재사용 가능한 협력을 얻을 수 있기 떄문이다.
- `역할`은 다른 것으로 교체할 수 있는 `책임의 집합`이다.
- 책임과 역할을 중심으로 협력을 바라보는 것이 바로 변경과 확장이 용이한 유연한 설계로 나아가는 첫걸음 이다.
- 역할은 객체가 참여할 수 있는 일종의 `슬롯`이다.
- 협력에 참여하는 후보가 여러 종류의 객체에 의해 수행될 필요가 있다면 그 후보는 역할이 되지만, 그렇지 않으면 객체가 된다.
- 유사한 협력들을 단순화하고 합치다 보면 자연스럽게 역할이 그 모습을 드러낼 것이다.
- 협력을 구체적인 객체가 아니라 추상적인 역할의 관점에서 설계하면 협력이 유연하고 재사용 가능해진다는 것이다.
- 상위 수준에서 협력을 설명하면 구체적인 객체들이 가지는 복잡ㅇ성을 제거하고 단순화해서 표현할 수 있다.
- 협력이라는 문맥 안에서 역할은 특정한 협력에 참여해서 책임을 수행하는 객체의 일부다.

---

( 24.1.3 ~ 계속 )
