---
title: Promise 들여다보기
date: '2022-02-23'
tags: ['자바스크립트', 'Promise', 'async-await', 'Thenable']
draft: false
summary: javascript Promise에 대해서 알아보자.
---

import Diagram from '@/components/Diagram'

프로미스에 대해서 깊게 한번 공부해보자.

## 등장 배경

아래와 같이 기능을 구현해야한다고 생각해봅시다.

1. A서버에서 이미지를 조회합니다.
2. 조회된 이미지를 압축합니다.
3. 이미지를 저장합니다.

3가지 기능 모두 비동기적으로 처리되는 기능들인데 동기적으로 처리하기 위해서는 어떻게 해야할까요?
아래와 같이 각 함수들의 기능이 완료되면 성공여부를 체크해서 인자로 받은 `callback` 함수를 실행시켜야 합니다. _(1)_

이러한 기능들이 많아질수록, `callback`의 깊이가 깊어지게 되고, 이를 `콜백지옥`이라고 합니다. _(2)_

```js
function fetchImage(url, callback) {
  var xmlHttp = new XMLHttpRequest();

  xmlHttp.onreadystatechange = function () {
    if(xmlHttp.readyState === xmlHttp.DONE) {
      if (this.status === 200 ) {
        callback(null, this.response); // (1)
      } else {
        callback(new Error("실패")); // (1)
      }
    }
  };
  xmlHttp.open("GET", url)
  xmlHttp.send();
 }
function compressImage(img, callback) {  ... }
function saveImage(img, callback) {  ... }

// 콜백 지옥
fetchImage('https://picsum.photos/500', function (err, response) {
  if (err) throw err;
  compressImage(response, function (err, response) {
    if (err) throw err;
    saveImage(response, function (err, response) { // (2)
      if (err) throw err;

      // ...
    })
  })
})
```

> 물론, 이러한 코드들도 써왔던 방식이고, 개선하는 방식들이 있습니다. [(참고 - Callback Hell)](http://callbackhell.com/)

이렇게 작성되는 코드를 개선하기위해 `Promise`가 등장하게 됩니다.

---

## 프로미스란?

`Promise`는 `'약속'`을 의미합니다.

자바스크립트는 싱글스레드로 **바로 처리할 수 없는 작업(비동기)** 에 대해서는 `Task`로 보내게 됩니다.
`Call Stack`에 남은 작업이 없을 때, `Event Loop`는 `Task`에 쌓여있는 작업을 다시 `Call Stack`으로 보내며, 이 때, 작업이 실행되고 최종 결과를 반환합니다.

위 상황에서 `Promise`는 **바로 처리할 수 없는 작업(비동기)** 에 사용되는 객체로, 최종 값을 즉시 반환하는 대신 작업이 완료되는 시점에 값을 제공하겠다는 `약속`을 반환합니다. _(pending)_

---

## 프로미스의 동작 방식

프로미스의 동작 방식을 이해하기 위해서는 두가지의 중요한 포인트가 있습니다.

1. 프로미스의 상태 _(pending, fulfilled, rejected)_
2. Producer 와 Consumer _(executor, then, catch, finally)_

<Diagram
  code={`
flowchart LR
  subgraph Producer
    direction LR
    P{pending} --resolve--> F[fulfilled]
    P --reject--> R[rejected]
    end
  subgraph Consumer
    direction LR
    T1[then - 1] --> T2[Then - 2] --> Finally[Finally]
    C[catch] --> Finally
    end
  F --> T1
  T1 -.다시 던지기.-> C
  R --> C
  R -.-> T1
  C -.-> T2
  T1 -.에러 처리 완료시.-> Finally
  
`}
/>

```js
const promise = new Promise(
  // Provider = executor
  (resolve, reject) => {
    setTimeout(() => {
      // boolean이 true값이면, resolve가 실행되므로, 밑에 있는 reject는 무시 됩니다.
      if (boolean) resolve(1) // Promise (<fullfilled>)
      reject(new Error('error')) // Promise (<rejected>)
    }, 500)
  }
)
  // Consumer
  .then(
    // then - 1
    (res) => {
      return res * 2
    },
    (err) => {
      throw err
    }
  )
  .catch((err) => {
    // catch
    console.log(err.message)
  })
  .then((res) => {
    // then - 2
    return res ? res * 2 : 1
  })
  .finally(() => {
    // finally
    console.log('finally')
  })

console.log(promise) // Promise (<pending>)
```

위 다이어그램에서 나타나듯이, `Promise`의 **최초 상태** 는 `pending` 입니다.
**boolean** 의 값이 **true** 가 되면, `resolve`가 실행되어 `Promise`의 상태가 `fulfilled`로 변경 됩니다. 반대로, **boolean** 값이 **false** 라고하면, `reject`가 실행되어, 상태는 `rejected`가 됩니다.

`Promise`가 처리`(resolve / reject)`되고 나면, 상태가 `pending` 에서 `fulfilled / rejected`로 변경됩니다. 이렇게 상태가 변경되면,

- **PromiseStatus: fulfilled**

  - Promise가 resolve되면 가장 먼저 `체이닝`된 [`then`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then) 혹은 [`finally`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally)가 실행 됩니다.
  - `then`은 프로미스의 성공을 처리할 수 있는 첫번쨰 인자`(onFulfilled)`와 실패를 처리할 수 있는 두번쨰 인자`(onRejected)`를 받습니다.
    - **onFulfilled**
      - resolve가 실행되면 then의 첫 번째 인자인 onFulfilled 함수가 실행 됩니다. 이때 resolve 실행시 들어간 인자를 onFulfilled의 인자로 받아 처리 할 수 있습니다.
      - 여기서 리턴된 값은 다음 `then`의 인자로 념어가게 됩니다.

- **PromiseStatus: rejected**
  - Promise가 reject되면 가장 먼저 `체이닝`되는 `(두번째 인자에 onRejected 함수가 있는) then` / [`catch`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch) / `finally` 를 실행합니다.
    - **onRejected**
      - reject가 실행되고 체이닝된 `then`에 두번째 인자인 onRejected 함수가 있으면 실행됩니다. onRejected 함수의 인자로 reject 실행시 들어간 인자를 받습니다.
        이 때, 에러가 처리되면 다음 `then` 혹은 (없다면) `finally`으로 넘어갑니다. 만약 에러를 처리하지 못하면 다음 `catch`로 넘길 수 있는데, throw를 통해서 다시 에러를 발생시키면 됩니다. [(다시 던지기)](https://ko.javascript.info/promise-error-handling#ref-320)
        - 만약 에러를 잡지 못하면, 전역스코프의 [unhandledrejection](https://developer.mozilla.org/en-US/docs/Web/API/Window/unhandledrejection_event) 이벤트가 발생하게 됩니다.

### 상황 별 에러 처리 예제

```js
// 상황 1
const promise = new Promise((resolve, reject) => reject(new Error('error')))
const f1 = (response) => Promise.reject(Error('then Error'))
const f2 = console.err

promise.then(f1).catch(f2) // (1)
promise.then(f1, f2) // (2)
```

- **[상황 1]** promise의 상태가 `rejected` 입니다. onResolve 함수인 `f1`은 실행되지 않습니다.

  - (1): `catch`에 잡혀 `f2` 함수가 실행됩니다.
  - (2): then의 두번째 인자인 onRejected 함수에 잡혀, `f2`가 실행 됩니다.

```js
// 상황 2
const promise = new Promise((resolve, reject) => resolve(new Error('error')))
const f1 = (response) => Promise.reject(Error('then Error'))
const f2 = console.err

promise.then(f1).catch(f2) // (1)
promise.then(f1, f2) // (2)
```

- **[상황 2]** promise의 상태가 `fulfilled` 입니다.
  - (1): 첫번째로 체이닝된 `then`으로 넘어가고 `f1` 함수가 실행됩니다. 여기서 `f1` 함수가 rejected를 반환하니, `catch`로 넘어가 `f2`에서 에러 처리를 하게 됩니다.
  - (2): (1)과 동일하게 `then`으로 넘어가고 `f1` 함수가 실행됩니다. 여기서 에러가 발생하지만 이를 잡을 수 있는 `catch`가 없으므로 에러를 잡을 수 없습니다.

---

## Promise API

### Promise.all

`Promise.all`은 순서를 보장 하는가?

- **요청 순서**에 대한 **응답 순서**는 보장한다.

- https://stackoverflow.com/questions/28066429/promise-all-order-of-resolved-values

```js
const myPromises = [
  new Promise((resolve) =>
    setTimeout(() => {
      resolve('A (slow)')
      console.log('A (slow)')
    }, 1000)
  ),
  new Promise((resolve) =>
    setTimeout(() => {
      resolve('B (slower)')
      console.log('B (slower)')
    }, 2000)
  ),
  new Promise((resolve) =>
    setTimeout(() => {
      resolve('C (fast)')
      console.log('C (fast)')
    }, 10)
  ),
]

Promise.all(myPromises).then(console.log)
```

### Promise.allSettled

- Promise.all 을 사용하여 폴리필 만들어보기

```
응답이 성공할 경우 – {status:"fulfilled", value:result}
에러가 발생한 경우 – {status:"rejected", reason:error}
```

### Promise.race

Promise.race를 사용하면 '경주(race)의 승자’가 나타난 순간 다른 프라미스의 결과 또는 에러는 무시됩니다.

### Promise.resolve

```js
let promise = new Promise((resolve) => resolve(value))
```

### Promise.reject

```js
let promise = new Promise((_, reject) => reject(value))
```

### Promise.any

- Promise.race와의 차이점

---

## 직접 만들어보기

---

## 기타 참고 내용

### 마이크로테스크

### Thenable

### 프로미스화

```js
function promisify(f, manyArgs = false) {
  return function (...args) {
    return new Promise((resolve, reject) => {
      function callback(err, ...results) { // f에 사용할 커스텀 콜백
        if (err) {
          reject(err);
        } else {
          // manyArgs가 구체적으로 명시되었다면, 콜백의 성공 케이스와 함께 이행 상태가 됩니다.
          resolve(manyArgs ? results : results[0]);
        }
      }

      args.push(callback);

      f.call(this, ...args);
    });
  };
};

// 사용법:
f = promisify(f, true);
f(...).then(arrayOfResults => ..., err => ...)
```

---

## 참고 레퍼런스

- http://callbackhell.com/
- https://ko.javascript.info/async
- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise
- https://dev.to/lydiahallie/javascript-visualized-promises-async-await-5gke
- https://github.com/rauschma/demo_promise
- https://velog.io/@teihong93/Promise-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0-1
- https://2ality.com/2014/10/es6-promises-api.html
- https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Using_promises#see_also
