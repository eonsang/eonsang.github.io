---
title: 다중 인스턴스에서 스케줄 중복 처리 방지
date: '2023-12-30'
tags: ['Nestjs', 'Schedule']
draft: false
summary: 최소 2개 이상의 인스턴스에서 동작하는 서비스에서 스케줄 중복 처리 방지하는 방법
---

서비스를 개발하다보면 스케줄 처리를 하는 부분들이 있습니다.

이번에 일정 주기마다 특정 유저를 조회해서 푸시를 보내야하는 기능이 추가됐는데, 백엔드 서버가 다중 인스턴스로 구현되어있다보니 각 인스턴스별로 스케줄이 실행되는 부분에 대한 고민을 하게 됐는데, 이를 어떤 방식을 선택했고, 코드를 작성했는지 정리합니다.

### 고민 거리

스케줄에 대한 라이브러리는 Nestjs에서 제공해주는 [@nestjs/schedule](https://docs.nestjs.com/techniques/task-scheduling)를 사용하기로 했습니다. 다만, 백엔드 서버가 2대로 돌아가고 있다보니, 스케줄이 실행될때 어떻게 하나의 인스턴스에서만 돌아가게 할건지에 대한 고민이 있었습니다.

생각나는 방법은 아래 4가지 있었습니다.

1. 백엔드 서버에 스케줄을 포함시키지 않고, 별도의 스크립트를 작성하여 람다 스케줄로 처리한다.
2. 큐를 하나 만들어서 한시간에 하나씩 메시지를 생성하여, 해당 메시지를 받은 인스턴스에서 처리하도록 한다.
3. 해당 작업을 API로 만들어서 특정 시간별로 트리거한다.
4. 각 인스턴스에서 스케줄러가 실행되기 전에 redis-key를 확인하고 잠금을 획득한 인스턴스만 실행되도록 한다.

최종적으로 4번을 선택하게 됐는데, 이유는 아래와 같습니다.

- 1번: 서버를 혼자 개발하면서 최대한 유지보수가 편하도록하면서, 레거시를 적게 쌓아야한다는 생각에 부적합했습니다.
- 2번: 특정시간마다 큐에 메시지를 넣어야 하므로, 메시지를 생성하는거도 스케줄로 처리시 똑같은 문제가 발생했습니다.
- 3번: 외부에 노출되는 API는 보안에 대한 부담과, 이 또한, EventBridge와 같은 스케줄을 사용하여 특정 시간마다 요청을 보내야하는 작업이 있었습니다.

4번을 선택한 이유는, 기존에 redis를 사용하고 있었어서, 추가해야할 인프라가 없었습니다. 또한 해당 스케줄 처리 시간이 수초안에 마무리되는 작업이라 서버에서 직접 돌려도 무리가 없다는 확신이 있었습니다.

무엇보다, 빠르게 적용하고 바로 배포를 할 수 있다는 장점이 있었습니다.

### 작업

레디스에는 `shedLock`, `RedLock`과 같은 분산락을 처리하는 다양한 방법이 있습니다. java/spring 환경에서는 관련 패키지와 예제들이 많은데, node/Nestjs 환경에서는 해당 락을 구현한 패키지를 찾아봐도 적당해 보이는 것들이 없어 `ShedLock`을 참고하여 간단히 적용했습니다.

```ts
export class SampleService {
  constructor(@InjectRedis() private readonly redis: Redis) {}

  @Cron(0 10-20/1 * * *)
  async sendNotification() {
    const LOCK_KEY = 'LOCK_KEY'
    /*
    * SETNX를 통해 키를 잡은 인스턴스만 실행합니다.
    * 해당 스케줄은 매 시간마다 돌아가고, 실행시간이 3분 내외라서 5분의 ttl을 설정했습니다.
    */
    const lock = await this.redis.set(LOCK_KEY, '1', 'EX', 60 * 5, 'NX');
    if(!lock) return;

    try {
        // 비즈니스 로직...
    }
    catch(e) {
        // 실패 처리...
    }
    finally {
        // 스케줄이 완료되면 키를 삭제합니다.
        await this.redis.del(LOCK_KEY);
    }
  }
}
```

위 코드를 간단히 설명하면, 여러 인스턴스에서 해당 스케줄이 시작했을때, redis의 `setnx` 를 통해서 해당 키를 잡은 인스턴스만 실행하도록 처리했습니다. 해당 스케줄은 3분 내외로 종료되는 스케줄이라 5분의 ttl을 설정했고, 해당 로직이 완료되면 finally에서 키를 삭제하도록 처리했습니다.

### 참고문서

- [레디스와 분산 락(1/2) - 레디스를 활용한 분산 락과 안전하고 빠른 락의 구현](https://hyperconnect.github.io/2019/11/15/redis-distributed-lock-1.html)
